import { FastifyRequest, FastifyReply } from 'fastify';
import axios from 'axios';
import dotenv from 'dotenv';
import path from 'path';
let currentConfig = { };

// Simple in-memory session (for demo; use a session store for production)
export const session = {
  accessKey: null as string | null,
  orgId: null as string | null,
};

dotenv.config({ path: path.resolve(process.cwd(), '../../web/.env.dev.web') });

function hasPermission(user: any) {
  return user && user.isCollaborator;
}

/**
 * POST /cli/config
 * - If called with { generateLocal: true }, returns a config object for local deployment (provider, plugins, etc.)
 *   as would be generated by an init script (e.g., ./launchdota.sh).
 * - Otherwise, updates the currentConfig with the posted body (if user has permission).
 */
export async function postConfigHandler(req: FastifyRequest, res: FastifyReply) {
  const user = (req as any).user || {};
  const body = (req.body && typeof req.body === 'object') ? req.body : {};

  // If generateLocal is set, fetch orgs, apps, deployments, and provide defaults
  if ((body as any).generateLocal) {
    const localConfig = {
      provider: process.env.DOTA_PROVIDER || 'local',
      plugins: process.env.DOTA_PLUGINS ? process.env.DOTA_PLUGINS.split(',') : ['auth', 'storage', 'metrics'],
      mode: process.env.DOTA_MODE || 'development',
    };
    // 1. List orgs
    let orgs = [];
    try {
      const orgsResp = await axios.get('http://localhost:4000/tenants');
      orgs = orgsResp.data.organisations || [];
    } catch (e) {}
    // 2. List apps (for first org or default)
    let apps = [];
    const orgId = orgs[0]?.id || '';
    try {
      const appsResp = await axios.get('http://localhost:4000/apps', { headers: { tenant: orgId } });
      apps = appsResp.data.apps || [];
    } catch (e) {}
    // 3. List deployments (for first app or default)
    let deployments = [];
    const appName = apps[0]?.name || '';
    try {
      const deploymentsResp = await axios.get(`http://localhost:4000/apps/${appName}/deployments`);
      deployments = deploymentsResp.data.deployments || [];
    } catch (e) {}
    // 4. Compose config for selection
    const configForSelection = {
      ...localConfig,
      orgs,
      apps,
      deployments,
      default: {
        org: orgs[0] || null,
        app: apps[0] || null,
        deployment: deployments[0] || null,
        version: '1.0.0'
      }
    };
    return res.send({ status: 'success', config: configForSelection });
  }
  // Otherwise, update config if user has permission
  if (!hasPermission(user)) {
    return res.status(403).send({ status: 'error', message: 'Permission denied' });
  }
  currentConfig = { ...currentConfig, ...body };
  res.send({ status: 'success', config: currentConfig });
}

export async function setOrgHandler(req: FastifyRequest, res: FastifyReply) {
  const { orgId } = req.body as { orgId?: string };
  if (typeof orgId === 'string' && orgId.length > 0) {
    session.orgId = orgId;
    return res.send({ status: 'success', orgId });
  }
  session.orgId = null;
  return res.status(400).send({ status: 'error', message: 'orgId required' });
}

export async function loginHandler(req: FastifyRequest, res: FastifyReply) {
  const { accessKey } = req.body as { accessKey?: string };
  if (accessKey === process.env.LOCAL_GOOGLE_TOKEN || accessKey === 'mock-google-token') {
    session.accessKey = accessKey ?? null;
    return res.send({ status: 'success', message: 'Logged in headless mode (mock token)' });
  }
  return res.status(401).send({ status: 'error', message: 'Invalid token' });
}

export async function getConfigHandler(req: FastifyRequest, res: FastifyReply) {
  // Return default config for emulated login
  const config = {
    DOTA_SERVER_URL: process.env.DOTA_SERVER_URL || 'http://localhost:3010',
    STORAGE_PROVIDER: process.env.STORAGE_PROVIDER || 'local',
    LOCAL_GOOGLE_TOKEN: process.env.LOCAL_GOOGLE_TOKEN || 'mock-google-token',
    NODE_ENV: process.env.NODE_ENV || 'development',
    EMULATED: process.env.EMULATED || 'true',
    REDIS_HOST: process.env.REDIS_HOST || 'localhost',
    REDIS_PORT: process.env.REDIS_PORT || '6379',
    DB_HOST: process.env.DB_HOST || 'localhost',
    DB_USER: process.env.DB_USER || 'root',
    DB_PASS: process.env.DB_PASS || 'root',
    DB_NAME: process.env.DB_NAME || 'codepushdb',
  };
  res.send({ status: 'success', config });
}

export async function getSeedDataHandler(req: FastifyRequest, res: FastifyReply) {
  // TODO: Return seed data based on config/env
  res.send({ status: 'seedData stub', seedData: {} });
}

export async function releaseUpdateHandler(req: FastifyRequest, res: FastifyReply) {
  // Use currentConfig and req.body to perform release
  res.send({ status: 'success', message: 'Release triggered', config: currentConfig });
}

export async function getAdoptionStatsHandler(req: FastifyRequest, res: FastifyReply) {
  // TODO: Call DOTA adoption stats API/CLI logic
  res.send({ status: 'adoptionStats stub', adoption: {} });
}

export async function deployFlowHandler(req: FastifyRequest, res: FastifyReply) {
  const user = (req as any).user || {};
  if (!hasPermission(user)) {
    return res.status(403).send({ status: 'error', message: 'Permission denied' });
  }
  let usedConfig = { ...currentConfig };
  const body = (req.body && typeof req.body === 'object') ? req.body as any : {};
  if (body.overrideConfig) {
    usedConfig = { ...usedConfig, ...body.overrideConfig };
    currentConfig = usedConfig;
  }
  // 2. Select org/app/deployment/version (from config or default)
  const org = (usedConfig as any).org || (usedConfig as any).default?.org || '';
  const app = (usedConfig as any).app || (usedConfig as any).default?.app || '';
  const deployment = (usedConfig as any).deployment || (usedConfig as any).default?.deployment || '';
  const version = (usedConfig as any).version || (usedConfig as any).default?.version || '1.0.0';
  // 3. RBAC: Check user permission for app/deployment (stubbed here)
  if (!hasPermission(user)) {
    return res.status(403).send({ status: 'error', message: 'No permission for this app/deployment' });
  }
  // 4. Trigger release (simulate or call real logic)
  const releaseResult = {
    status: 'success',
    message: `Release triggered for org=${org}, app=${app}, deployment=${deployment}, version=${version}`,
    config: usedConfig
  };
  // 5. Fetch adoption/feedback stats (simulate or call real logic)
  const adoptionStats = {
    status: 'success',
    adoption: {
      deploymentKey: deployment,
      adoptionRate: 'implement real logic'
    }
  };
  res.send({
    status: 'success',
    steps: {
      config: usedConfig,
      release: releaseResult,
      adoption: adoptionStats
    }
  });
}

export async function getOverviewHandler(req: FastifyRequest, res: FastifyReply) {
  try {
    const headers = {
      authorization: `Bearer cli-${session.accessKey}`,
      tenant: session.orgId || '',
    };
    console.log("headers ::", headers);
    // 1. Fetch orgs (tenants)
    const orgsResp = await axios.get('http://localhost:3000/tenants', { headers });
    const orgs = orgsResp.data.organisations || [];
    // 2. For each org, fetch apps
    const orgsWithApps = await Promise.all(orgs.map(async (org: any) => {
      let apps = [];
      try {
        const appsResp = await axios.get('http://localhost:3000/apps', { headers: { ...headers, tenant: org.id } });
        apps = appsResp.data.apps || [];
      } catch (e) {}
      // 3. For each app, fetch latest release (assuming /apps/:appName/deployments or similar)
      const appsWithReleases = await Promise.all(apps.map(async (app: any) => {
        let latestRelease = null;
        try {
          const deploymentsResp = await axios.get(`http://localhost:3000/apps/${app.name}/deployments`, { headers: { ...headers, tenant: org.id } });
          const deployments = deploymentsResp.data.deployments || [];
          latestRelease = deployments[0] || null;
        } catch (e) {}
        return { ...app, latestRelease };
      }));
      return { ...org, apps: appsWithReleases };
    }));
    res.send({ status: 'success', orgs: orgsWithApps });
  } catch (error: any) {
    res.status(500).send({ status: 'error', message: error.message });
  }
} 