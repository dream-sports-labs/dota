"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.session = void 0;
exports.postConfigHandler = postConfigHandler;
exports.setOrgHandler = setOrgHandler;
exports.loginHandler = loginHandler;
exports.getConfigHandler = getConfigHandler;
exports.getSeedDataHandler = getSeedDataHandler;
exports.releaseUpdateHandler = releaseUpdateHandler;
exports.getAdoptionStatsHandler = getAdoptionStatsHandler;
exports.deployFlowHandler = deployFlowHandler;
exports.getOverviewHandler = getOverviewHandler;
const axios_1 = __importDefault(require("axios"));
const dotenv_1 = __importDefault(require("dotenv"));
const path_1 = __importDefault(require("path"));
let currentConfig = {};
// Simple in-memory session (for demo; use a session store for production)
exports.session = {
    accessKey: null,
    orgId: null,
};
dotenv_1.default.config({ path: path_1.default.resolve(process.cwd(), '../../web/.env.dev.web') });
function hasPermission(user) {
    return user && user.isCollaborator;
}
/**
 * POST /cli/config
 * - If called with { generateLocal: true }, returns a config object for local deployment (provider, plugins, etc.)
 *   as would be generated by an init script (e.g., ./launchdota.sh).
 * - Otherwise, updates the currentConfig with the posted body (if user has permission).
 */
async function postConfigHandler(req, res) {
    const user = req.user || {};
    const body = (req.body && typeof req.body === 'object') ? req.body : {};
    // If generateLocal is set, fetch orgs, apps, deployments, and provide defaults
    if (body.generateLocal) {
        const localConfig = {
            provider: process.env.DOTA_PROVIDER || 'local',
            plugins: process.env.DOTA_PLUGINS ? process.env.DOTA_PLUGINS.split(',') : ['auth', 'storage', 'metrics'],
            mode: process.env.DOTA_MODE || 'development',
        };
        // 1. List orgs
        let orgs = [];
        try {
            const orgsResp = await axios_1.default.get('http://localhost:4000/tenants');
            orgs = orgsResp.data.organisations || [];
        }
        catch (e) { }
        // 2. List apps (for first org or default)
        let apps = [];
        const orgId = orgs[0]?.id || '';
        try {
            const appsResp = await axios_1.default.get('http://localhost:4000/apps', { headers: { tenant: orgId } });
            apps = appsResp.data.apps || [];
        }
        catch (e) { }
        // 3. List deployments (for first app or default)
        let deployments = [];
        const appName = apps[0]?.name || '';
        try {
            const deploymentsResp = await axios_1.default.get(`http://localhost:4000/apps/${appName}/deployments`);
            deployments = deploymentsResp.data.deployments || [];
        }
        catch (e) { }
        // 4. Compose config for selection
        const configForSelection = {
            ...localConfig,
            orgs,
            apps,
            deployments,
            default: {
                org: orgs[0] || null,
                app: apps[0] || null,
                deployment: deployments[0] || null,
                version: '1.0.0'
            }
        };
        return res.send({ status: 'success', config: configForSelection });
    }
    // Otherwise, update config if user has permission
    if (!hasPermission(user)) {
        return res.status(403).send({ status: 'error', message: 'Permission denied' });
    }
    currentConfig = { ...currentConfig, ...body };
    res.send({ status: 'success', config: currentConfig });
}
async function setOrgHandler(req, res) {
    const { orgId } = req.body;
    if (typeof orgId === 'string' && orgId.length > 0) {
        exports.session.orgId = orgId;
        return res.send({ status: 'success', orgId });
    }
    exports.session.orgId = null;
    return res.status(400).send({ status: 'error', message: 'orgId required' });
}
async function loginHandler(req, res) {
    const { accessKey } = req.body;
    if (accessKey === process.env.LOCAL_GOOGLE_TOKEN || accessKey === 'mock-google-token') {
        exports.session.accessKey = accessKey ?? null;
        return res.send({ status: 'success', message: 'Logged in headless mode (mock token)' });
    }
    return res.status(401).send({ status: 'error', message: 'Invalid token' });
}
async function getConfigHandler(req, res) {
    // Return default config for emulated login
    const config = {
        DOTA_SERVER_URL: process.env.DOTA_SERVER_URL || 'http://localhost:3010',
        STORAGE_PROVIDER: process.env.STORAGE_PROVIDER || 'local',
        LOCAL_GOOGLE_TOKEN: process.env.LOCAL_GOOGLE_TOKEN || 'mock-google-token',
        NODE_ENV: process.env.NODE_ENV || 'development',
        EMULATED: process.env.EMULATED || 'true',
        REDIS_HOST: process.env.REDIS_HOST || 'localhost',
        REDIS_PORT: process.env.REDIS_PORT || '6379',
        DB_HOST: process.env.DB_HOST || 'localhost',
        DB_USER: process.env.DB_USER || 'root',
        DB_PASS: process.env.DB_PASS || 'root',
        DB_NAME: process.env.DB_NAME || 'codepushdb',
    };
    res.send({ status: 'success', config });
}
async function getSeedDataHandler(req, res) {
    // TODO: Return seed data based on config/env
    res.send({ status: 'seedData stub', seedData: {} });
}
async function releaseUpdateHandler(req, res) {
    // Use currentConfig and req.body to perform release
    res.send({ status: 'success', message: 'Release triggered', config: currentConfig });
}
async function getAdoptionStatsHandler(req, res) {
    // TODO: Call DOTA adoption stats API/CLI logic
    res.send({ status: 'adoptionStats stub', adoption: {} });
}
async function deployFlowHandler(req, res) {
    const user = req.user || {};
    if (!hasPermission(user)) {
        return res.status(403).send({ status: 'error', message: 'Permission denied' });
    }
    let usedConfig = { ...currentConfig };
    const body = (req.body && typeof req.body === 'object') ? req.body : {};
    if (body.overrideConfig) {
        usedConfig = { ...usedConfig, ...body.overrideConfig };
        currentConfig = usedConfig;
    }
    // 2. Select org/app/deployment/version (from config or default)
    const org = usedConfig.org || usedConfig.default?.org || '';
    const app = usedConfig.app || usedConfig.default?.app || '';
    const deployment = usedConfig.deployment || usedConfig.default?.deployment || '';
    const version = usedConfig.version || usedConfig.default?.version || '1.0.0';
    // 3. RBAC: Check user permission for app/deployment (stubbed here)
    if (!hasPermission(user)) {
        return res.status(403).send({ status: 'error', message: 'No permission for this app/deployment' });
    }
    // 4. Trigger release (simulate or call real logic)
    const releaseResult = {
        status: 'success',
        message: `Release triggered for org=${org}, app=${app}, deployment=${deployment}, version=${version}`,
        config: usedConfig
    };
    // 5. Fetch adoption/feedback stats (simulate or call real logic)
    const adoptionStats = {
        status: 'success',
        adoption: {
            deploymentKey: deployment,
            adoptionRate: 'implement real logic'
        }
    };
    res.send({
        status: 'success',
        steps: {
            config: usedConfig,
            release: releaseResult,
            adoption: adoptionStats
        }
    });
}
async function getOverviewHandler(req, res) {
    try {
        const headers = {
            authorization: `Bearer cli-${exports.session.accessKey}`,
            tenant: exports.session.orgId || '',
        };
        console.log("headers ::", headers);
        // 1. Fetch orgs (tenants)
        const orgsResp = await axios_1.default.get('http://localhost:3000/tenants', { headers });
        const orgs = orgsResp.data.organisations || [];
        // 2. For each org, fetch apps
        const orgsWithApps = await Promise.all(orgs.map(async (org) => {
            let apps = [];
            try {
                const appsResp = await axios_1.default.get('http://localhost:3000/apps', { headers: { ...headers, tenant: org.id } });
                apps = appsResp.data.apps || [];
            }
            catch (e) { }
            // 3. For each app, fetch latest release (assuming /apps/:appName/deployments or similar)
            const appsWithReleases = await Promise.all(apps.map(async (app) => {
                let latestRelease = null;
                try {
                    const deploymentsResp = await axios_1.default.get(`http://localhost:3000/apps/${app.name}/deployments`, { headers: { ...headers, tenant: org.id } });
                    const deployments = deploymentsResp.data.deployments || [];
                    latestRelease = deployments[0] || null;
                }
                catch (e) { }
                return { ...app, latestRelease };
            }));
            return { ...org, apps: appsWithReleases };
        }));
        res.send({ status: 'success', orgs: orgsWithApps });
    }
    catch (error) {
        res.status(500).send({ status: 'error', message: error.message });
    }
}
